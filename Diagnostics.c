#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     ldrive,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rdrive,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     flagspinner,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     blockkicker,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     wenchl,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     wenchr,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    autoblock,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    irservo,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    wedgel,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    wedger,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    sabotage,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

//#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "hitechnic-touchmux.h"
//#include "Ring_It_Up_diagnosticsincludebot2.c"

task main()
{
  int count = 1;
  int maxcount = 3;

  while(true)
  {
    if (nNxtButtonPressed == 1)
    {
      wait10Msec(50);
      count = count + 1;
    }

    if (count <= 0)                // Check for wrap around 0
    {
      count = maxcount;
    }

    if (nNxtButtonPressed == 2)
    {
      wait10Msec(50);
      count = count - 1;
    }

    if (count > maxcount)         // Check for wrap around maxcount
    {
      count = 1;
    }
    if(nNxtButtonPressed == kEnterButton)
    {
    	switch(count)
    	{
    		case 1:
    		//call drive train
    		break;

    		case 2:
    		//call wench
    		break;

    		case 3:
    		//call blockkicker
    		break;
    	}
    }

    //  Display Diagnostics to be executed
    eraseDisplay();
    switch (count)
    {
      case 1:
      eraseDisplay();
      nxtDisplayCenteredTextLine(1, "%s", "Drivetrain");      // Display Drivetrain on line 1.
      nxtDisplayCenteredTextLine(3, "%s", "Press Orange Button"); //tells to hit orange button to enter drive train diagnostic
      wait1Msec(30);                                // Wait 50 milliseconds (helps refresh rate of LCD screen).
      //DriveTrainDiagnostic();
      break;  // End case 1

      case 2:
      eraseDisplay();
      nxtDisplayCenteredTextLine(1, "%s", "Wench/Lift");        // Display RingArm on line 1.
      nxtDisplayCenteredTextLine(3, "%s", "Press Orange Button"); //tells to hit orange button to enter drive train diagnostic
      wait1Msec(30);                                // Wait 50 milliseconds (helps refresh rate of LCD screen).
      //RingArmDiagnostic();
      break;  // End case 2

      case 3:
      eraseDisplay();
      nxtDisplayCenteredTextLine(1, "%s", "Block Kicker");  // Display Ball Harvester on line 3.
      nxtDisplayCenteredTextLine(3, "%s", "Press Orange Button"); //tells to hit orange button to enter drive train diagnostic
      wait1Msec(30);                                // Wait 50 milliseconds (helps refresh rate of LCD screen).
      //LateralBayonetDiagnostic();
      break;  // End case 3
    }  // End switch
  }
}
